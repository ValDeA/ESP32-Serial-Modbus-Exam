#include <HardwareSerial.h>
#include <Wire.h>
#include "EEPROM.h"

#define rts_485             26

#define Txd                 1
#define Rxd                 3

#define RS485_BUFFER_MAX     1024


#define MAP_ADDRESS_SIZE    100   // Map Address Size
#define BROADCAST           0x00

#define READ_MULTIPLE       0x03
#define WRITE_SINGLE        0x06


HardwareSerial  rs485Serial(0);


byte slaveAddress = 0x01;
byte mapAddress[MAP_ADDRESS_SIZE] = { 
    0x00, 0x00,     // Fan Speed
    0x00, 0x00,     // Power Status
    0x00, 0x00,     // System Reboot
    0x00, 0x01,     // Slave Address, def: 0x01
  };

byte rxSerialData[RS485_BUFFER_MAX] = { 0, };


byte address;

void setup() {
//  Serial.begin(115200); // PC와의 통신 설정
  rs485Serial.begin(9600, SERIAL_8N1, Rxd, Txd); // RS485 모듈과의 통신 설정
  setPinMode();

  // Slave Address
  EEPROM.begin(10);
  slaveAddress = EEPROM.readByte(0);
//  consoleLog((String) slaveAddress);
//  slaveAddress = 0x02;
  consoleLog((String) slaveAddress);
  if(slaveAddress == 0x00 || slaveAddress == 0xFF) { slaveAddress = 0x01; }
  consoleLog(((String) "Slave Address " + slaveAddress));

  xTaskCreate(
    taskRS485,
    "rs485_task",
    10000,
    NULL,
    1,
    NULL
  );

  printf("Setup\n");
}

void loop() {
  delay(1000);
}


void setPinMode() {
  pinMode(rts_485, OUTPUT);
  digitalWrite(rts_485, LOW); // Read Mode
}


void taskRS485(void* param) {
  while(1) {
    rs485Read();

    delay(100);
  }
}

void rs485Read(){
  unsigned short us_cnt       = 0;
  unsigned short us_readCnt   = 0;
  
  if(rs485Serial.available() > 0) {
    us_readCnt = rs485Serial.available();
    delay(50);
    
    while(rs485Serial.available() > 0) {
      if(rs485Serial.available() > us_readCnt) {
        us_readCnt = rs485Serial.available();
        delay(50);
      } else if(rs485Serial.available() == us_readCnt) {
        break;
      }
    }
  }

  while(us_readCnt > 0) {
    byte ch = rs485Serial.read();
    rxSerialData[us_cnt] = ch;
    
    us_cnt++;
    if(us_cnt >= RS485_BUFFER_MAX) break;
    if(us_readCnt == us_cnt) break;
  }

  if(us_cnt > 0) {
    if(checkRS485CRC(us_cnt) == true) {      
      processRS485Read(rxSerialData, us_cnt);
      us_cnt = 0;
    }
  }


      
//  unsigned short us_cnt = 0;
//  unsigned long  ul_timeout = 500;
//  unsigned long  ul_start;
//      
//  if(serialRS485.available() > 0) {
//    delay(100); // 한글자씩 읽히는 것을 방지하기 위한 딜레이
//    ul_start = millis();
//
//    while(serialRS485.available() > 0) {
//      byte ch = serialRS485.read();
//      rxSerialData[us_cnt] = ch;
//      
//      us_cnt++;
//      delay(10);
//      if(millis() - ul_start > ul_timeout) break;
//      if(us_cnt >= RS485_BUFFER_MAX) break;
//    }
//
//    if(us_cnt > 0) {
////      consoleLog((String) "Receive Message! Count : " + us_cnt);
//      
//      if(checkRS485CRC(us_cnt) == true) {      
//        processRS485Read(rxSerialData, us_cnt);
//        us_cnt = 0;
//      }
//    }
//    
//  }
  
}

void rs485Write(const char* packet, int len) {
  digitalWrite(rts_485, HIGH); // Write Mode
  rs485Serial.write(packet, sizeof(char) * len);

  delay(200);
  digitalWrite(rts_485, LOW); // Read Mode
}
void rs485Write(byte* packet, int len) {
  digitalWrite(rts_485, HIGH); // Write Mode
  rs485Serial.write(packet, sizeof(byte) * len);

  delay(200);
  digitalWrite(rts_485, LOW); // Read Mode
}



bool checkRS485CRC(int len) {
  uint16_t crc = CRC_Compute(rxSerialData, len - 2);
  uint8_t crcHi = (uint8_t)(crc >> 8);
  uint8_t crcLo = (uint8_t)(crc & 0x00FF);

  if(crcHi != rxSerialData[6] || crcLo != rxSerialData[7]){
    #ifdef _DEBUG_RS485
    printf("Get = %02X%02X, Cal = %02X%02X\n", rxSerialData[6], rxSerialData[7], crcHi, crcLo);
    #endif
    return false;
  } else {
    return true;
  }
}

void processRS485Read(unsigned char* packet, int len) {
  byte    slaveAddr       = packet[0];
  byte    functionCode    = packet[1];
  byte    regAddr[2]      = { packet[2], packet[3] };
  byte    readCount[2]    = { packet[4], packet[5] };
  byte    crc[2]          = { packet[6], packet[7] };


  if(slaveAddress == slaveAddr || slaveAddress == BROADCAST) {
    if(slaveAddress == slaveAddr) {       // 결과 Response
      makeRS485Response(packet, len);
    }
    if(functionCode == READ_MULTIPLE) {            // Multiple Read
      
    } else if(functionCode == WRITE_SINGLE) {     // Single Write
      if(regAddr[0] == 0x00 && regAddr[1] == 0x03) setSlaveAddress((uint16_t) (((readCount[0] << 8) * 255) + (readCount[1])));
    }


  } else {
    return;
  }

}



void readRS485(byte* packet, int start, int len) {
  if(start + len > MAP_ADDRESS_SIZE) return; // 잘못된 범위

  byte readData[RS485_BUFFER_MAX] = { 0, };
  
  for(int i=start; i<start+len; i++) {
    readData[i - start] = packet[i];
  }
}


void makeRS485Response(byte* packet, int len) {
  byte    slaveAddr       = packet[0];
  byte    functionCode    = packet[1];
  byte    regAddr[2]      = { packet[2], packet[3] };
  byte    readCount[2]    = { packet[4], packet[5] };
  byte    crc[2]          = { packet[6], packet[7] };

  if(functionCode == WRITE_SINGLE) {
    rs485Write(packet, 8);
    
  } else if(functionCode == READ_MULTIPLE) {
    uint16_t readStart = (regAddr[0] << 8) + regAddr[1];
    uint16_t readLength = (readCount[0] << 8) + readCount[1];
    uint16_t writeLength = readLength * 2;
    uint16_t totalLength = 5 + writeLength;

    byte* generatedPacket = (byte *) malloc(totalLength);
    generateMessage(generatedPacket, readStart, writeLength);
    rs485Write(generatedPacket, totalLength);
    free(generatedPacket);
  }
  
}



void generateMessage(byte* packet, uint16_t i_start, uint16_t u8_len) {
  uint16_t  totalLength   = 5 + u8_len;
  uint8_t   bodyLength    = 0;
  
  packet[0] = slaveAddress;
  packet[1] = READ_MULTIPLE;

  for(int i=0; i<u8_len; i++) {
    packet[3 + i] = mapAddress[i_start + i];
    bodyLength++;
  }
  packet[2] = bodyLength & 0xFF;

  uint16_t computeCRC = CRC_Compute(packet, totalLength - 2);
  packet[totalLength - 1] = (computeCRC)      & 0xFF;
  packet[totalLength - 2] = (computeCRC >> 8) & 0xFF;
}


void setSlaveAddress(uint16_t u16_addr) {
  if(u16_addr < 1 || u16_addr > 255) return;
  byte by_addr = u16_addr & 0xFF;

  EEPROM.writeByte(0, by_addr);
  EEPROM.commit();

  slaveAddress = by_addr;
}




/**********************************************************************/
void consoleLog(String strMsg) {
  const char* msg = strMsg.c_str();
  int len = strMsg.length();
  rs485Write(msg, len);
}



const unsigned char auchCRCHi[] = {
  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
  0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
  0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
  0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
  0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
  0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
  0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
  0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
  0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
  0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40
};
const unsigned char auchCRCLo[] = {
  0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,0x04,
  0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,0x08,0xC8,
  0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,0x1D,0x1C,0xDC,
  0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,0x11,0xD1,0xD0,0x10,
  0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,0x37,0xF5,0x35,0x34,0xF4,
  0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,0x3B,0xFB,0x39,0xF9,0xF8,0x38,
  0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,
  0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,
  0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,
  0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,
  0x78,0xB8,0xB9,0x79,0xBB,0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,
  0xB4,0x74,0x75,0xB5,0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,
  0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,
  0x9C,0x5C,0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,
  0x88,0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
  0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,0x40
};

unsigned short int CRC_Compute(unsigned char * pushMsg,unsigned char usDataLen)
{
  unsigned char uchCRCHi = 0xff;
  unsigned char uchCRCLo = 0xff;
  unsigned char uIndex;
  
  while(usDataLen--)
  {
    uIndex = uchCRCHi^ *pushMsg++;
    uchCRCHi = uchCRCLo^ auchCRCHi[uIndex];
    uchCRCLo = auchCRCLo[uIndex];
  }
  return (uchCRCHi << 8 | uchCRCLo);
}
